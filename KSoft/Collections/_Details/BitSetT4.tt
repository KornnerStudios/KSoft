<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension="cs" #>
<#@ assembly name="$(VitaSolutionFamilyBinPath)KSoft.T4.dll" #>
<#@ import namespace="KSoft.T4" #>
<#@ import namespace="KSoft.T4.Bitwise" #>
using System;
using Contracts = System.Diagnostics.Contracts;
using Contract = System.Diagnostics.Contracts.Contract;

namespace KSoft.Collections
{
	using StateFilterEnumerator = IReadOnlyBitSetEnumerators.StateFilterEnumerator;

	using StateFilterEnumeratorWrapper = EnumeratorWrapper<int, IReadOnlyBitSetEnumerators.StateFilterEnumerator>;

	partial class BitSet
	{
<# foreach (var state_def in CollectionsT4.BitStateDefs) { #>
		/// <summary>Get the bit index of the next bit which is <#= state_def.DocNameVerbose #></summary>
		/// <param name="startBitIndex">Bit index to start at</param>
		/// <returns>The next <#= state_def.DocName #> bit index, or -1 if one isn't found</returns>
		public int Next<#= state_def.ApiName #>BitIndex(int startBitIndex = 0)
		{
			return NextBitIndex(startBitIndex, <#= state_def.ValueKeyword #>);
		}
		/// <summary>Enumeration of bit indexes in this BitSet which are <#= state_def.DocNameVerbose #></summary>
		public StateFilterEnumeratorWrapper <#= state_def.ApiName #>BitIndices { get {
			return new StateFilterEnumeratorWrapper(new StateFilterEnumerator(this, <#= state_def.ValueKeyword #>));
		} }

<# } #>

<# for (var op = BitOperation.kFirst; op <= BitOperation.kLast; op++) { #>
		public <#= op.ResultType() #> <#= op #>Bits(int startBitIndex, int bitCount)
		{
			Contract.Requires<ArgumentOutOfRangeException>(startBitIndex >= 0 && startBitIndex < Length);
			Contract.Requires<ArgumentOutOfRangeException>((startBitIndex+bitCount) <= Length);

			if (bitCount <= 0)
				return <#= op.ResultDefault() #>;
			
			int last_bit_index = (startBitIndex+bitCount) - 1;
			var from_word_index = kVectorIndexInT(startBitIndex);
			var last_word_index = kVectorIndexInT(last_bit_index);

			var from_word_mask = kVectorElementSectionBitMask(from_word_index);
			var last_word_mask = GetCabooseRetainedBitsMask(last_word_index);

			if (from_word_index == last_word_index)
			{
				var mask = from_word_mask & last_word_mask;
<# if (op.IsNotPure()) { #>
				RecalculateCardinalityUndoRound(from_word_index);
				<#= op.FlagsMethod() #>(ref mArray[from_word_index], mask);
<#		if (op.RequiresCardinalityReUpdate()) { #>
				RecalculateCardinalityRound(from_word_index);
<#		} #>
<# } else if (op == BitOperation.Test) { #>
				return <#= op.FlagsMethod() #>(mArray[from_word_index], mask);
<# } #>
			}
			else
			{
<# if (op.IsNotPure()) { #>
				RecalculateCardinalityUndoRound(from_word_index);
				<#= op.FlagsMethod() #>(ref mArray[from_word_index], from_word_mask);
<#		if (op.RequiresCardinalityReUpdate()) { #>
				RecalculateCardinalityRound(from_word_index);
<#		} #>
<# } else if (op == BitOperation.Test) { #>
				if (<#= op.FlagsMethod() #>(mArray[from_word_index], from_word_mask))
					return true;
<# } #>

				for (int x = from_word_index+1; x < last_word_index; x++)
				{
<# if (op.IsNotPure()) { #>
					RecalculateCardinalityUndoRound(x);
<#		if (op == BitOperation.Toggle) { #>
					<#= op.FlagsMethod() #>(ref mArray[x], mArray[x]);
<#		} else { #>
					mArray[x] = <#= op == BitOperation.Set ? "kWordAllBitsSet" : "kWordAllBitsClear" #>;
<#		} #>
<#		if (op == BitOperation.Set) { #>
					Cardinality += kWordBitCount;
<#		} else if (op == BitOperation.Toggle) { #>
					RecalculateCardinalityRound(x);
<#		} #>
<# } else if (op == BitOperation.Test) { #>
					if (mArray[x] > kWordAllBitsClear)
						return true;
<# } #>
				}

<# if (op.IsNotPure()) { #>
				RecalculateCardinalityUndoRound(last_word_index);
				<#= op.FlagsMethod() #>(ref mArray[last_word_index], last_word_mask);
<#		if (op.RequiresCardinalityReUpdate()) { #>
				RecalculateCardinalityRound(last_word_index);
<#		} #>
<# } else if (op == BitOperation.Test) { #>
				return <#= op.FlagsMethod() #>(mArray[last_word_index], last_word_mask);
<# } #>
			}
		}

<# } #>
	};
}